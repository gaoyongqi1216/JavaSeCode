
1. 线程间通信的理解
当我们`需要多个线程`来共同完成一件任务，并且我们希望他们`有规律的执行`，那么多线程之间需要一些通信机制，
可以协调它们的工作，以此实现多线程共同操作一份数据。

2. 涉及到三个方法的使用：
1. wait：线程不再活动，不再参与调度，进入 `wait set` 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个`特别的动作`，也即“`通知（notify）`”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（`ready queue`）中
2. notify：则选取所通知对象的 wait set 中的一个线程释放；
3. notifyAll：则释放所通知对象的 wait set 上的全部线程。


3. 注意点：
1. wait方法与notify方法必须要由`同一个锁对象调用`。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
3. wait方法与notify方法必须要在`同步代码块`或者是`同步函数`中使用。因为：必须要`通过锁对象`调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。

4. 案例：
案例1：使用两个线程打印 1-100。线程1, 线程2 交替打印
案例2：生产者&消费者
生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有
固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品
了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来
取走产品。


5. wait() 和 sleep()的区别？
相同点：一旦执行，当前线程都会进入阻塞状态
不同点：
    ①：声明的位置：wait()声明在object类中；sleep()声明在Thread类中，静态的
    ②：使用的位置不同：wait()只能使用在同步代码块或者同步方法中；sleep()可以在任何使用的场景
    ③：使用在同步代码块或者同步方法中：wait()一旦执行，会释放同步监视器；sleep()不会
    ④：结束阻塞的方式：wait()到达指定的时间自动结束阻塞，或通过调用notify()唤醒，结束阻塞
                    sleep()到达指定的时间自动结束阻塞
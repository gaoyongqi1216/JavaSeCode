

除了使用synchronized同步机制处理线程安全问题之外，还可以使用jdk5.0提供的Lock锁的方式

1. 步骤：
  //1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例
 //2. 调动lock()，实现需共享的代码的锁定
  //3. 调用unlock()，释放共享代码的锁定
2. 面试题：
synchronized同步的方式 与Lock的对比 ？
1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁
2. Lock只有代码块锁，synchronized有代码块锁和方法锁
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。
4. （了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以
5. （了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以

> 说明：开发建议中处理线程安全问题优先使用顺序为：

> •    Lock ----> 同步代码块 ----> 同步方法



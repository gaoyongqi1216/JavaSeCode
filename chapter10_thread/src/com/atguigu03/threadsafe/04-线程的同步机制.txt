
线程的安全问题与线程的同步机制

1. 多线程卖票，出现的问题：出现了重票和错票的问题

2. 什么原因导致的？
    线程1 操作 ticker 的过程中，尚未结束的情况下，其他线程也参与进来再对ticket进行操作

3. 如何解决？
    必须保证一个线程在操作ticket的过程中，其他线程必须等待，直到线程操作ticket结束以后，其他线程才可以
 继续操作ticket。

4. Java是如何解决线程的安全问题的？
    使用线程的同步机制
方式1：同步代码块
    synchronized(同步监视器){
        //需要被同步到代码
    }
说明：
    ① ：需要被同步的代码，即为操作共享数据的代码
    ② ：共享数据，即多个线程多需要操作的数据，比如ticket。
    ③ ：需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其它线程必须等待
    ④ ：同步监视器，俗称锁，哪个线程获取了锁，哪个线程就能执行需要被同步的代码
    ⑤ ：同步监视器，可以使用任何一个类的对象，但是多个线程必须公用同一个同步监视器
注意：
    ①在实现Runnable接口的方式中，同步监视器可以考虑使用：this
    ②在继承Thread类的方式中，同步监视器要慎用this

方式2：同步方法

说明：
    ① ：如果操作共享数据代码完整的声明在了一个方法中，那么我们就可以将此方法声明为同步方法即可
    ② ： 非静态的同步方法，默认同步监视器是this
      静态的同步方法，默认同步监视器是当前类本身。

5. synchronized好处：解决了线程的安全问题。

   弊端：在操作共享数据时，多线程其实是串行执行的，意味着性能低。


